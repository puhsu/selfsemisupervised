# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_cifar.ipynb (unless otherwise specified).

__all__ = ['get_overlap', 'CifarFactory']

# Cell
import numpy as np
import matplotlib.pyplot as plt

from fastai2.basics import L
from fastai2.data.external import untar_data, URLs
from fastai2.data.transforms import *
from fastai2.vision.core import *
from fastai2.vision.learner import *
from fastai2.vision.models.xresnet import xresnet34
from fastai2.data.core import Datasets, DataLoader, TfmdDL
from fastai2.callback.schedule import LRFinder

from collections import Counter

# Cell
def get_overlap(first, second, n_same):
    "Generate set with `n_same` random items from `first` and other from `second`"

    assert set(first) & set(second) == set(), "Two sets already overlap!"
    assert 0 <= n_same <= len(second), "Too many elements requested"

    n_diff = len(second) - n_same

    same = list(np.random.choice(first, n_same, replace=False))
    other = list(np.random.choice(second, n_diff, replace=False))

    return same + other

# Cell
class CifarFactory():
    "Create different versions of cifar dataset splits"
    def __init__(self, seed=42, n_labeled=400, n_same_cls=1):
        """
        Initialize cifar split
        Args:
            n_labeled - labeled image per class
            n_same_cls - overlap between labeled and unlabeled classes
        """

        self.seed = seed
        self.n_labeled = n_labeled
        self.n_same_cls = n_same_cls

        # Classes split as in paper
        self.animals  = ["bird", "cat", "deer", "dog", "frog", "horse"]
        self.other    = ["ship", "truck", "airplane", "automobile"]

    def splits_from_path(self, path):
        "Create all things needed to setup fastai datasets. returns: fnames, (train, test, unsup)"
        np.random.seed(self.seed)

        # Get all cifar files
        fnames = get_image_files(path)
        labels = L([parent_label(f) for f in fnames])

        # Get only relevant classes
        sup_cls = self.animals
        unsup_cls = get_overlap(self.animals, self.other, self.n_same_cls)
        mask = labels.map(lambda l: l in sup_cls + unsup_cls)
        fnames = fnames[mask]
        labels = labels[mask]

        all_train, test = map(L, GrandparentSplitter("train", "test")(fnames))
        test = test.filter(lambda i: labels[i] in sup_cls)

        all_train = all_train[np.random.permutation(len(all_train))]

        # Split on labeled and unlabeled parts
        class_counts = Counter()
        n_labeled = self.n_labeled
        train, unsup = L(), L()

        for i in all_train:
            l = labels[i]

            if class_counts[labels[i]] < n_labeled:
                class_counts[labels[i]] += 1
                if l in sup_cls: train.append(i)
            elif l in unsup_cls:
                unsup.append(i)

        return fnames, (train, test, unsup)
